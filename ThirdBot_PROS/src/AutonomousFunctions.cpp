#include "main.h"
#include "Sensors.hpp"
#include "Variables.hpp"
#include "DriveFunctions.hpp"
#include "LiftFunctions.hpp"
#include "RollerFunctions.hpp"
#include "TilterFunctions.hpp"


/*
 Uses the torque exerted by the motors to detect when a cube is present in the
 inner rollers(arms). This function is to be used in autonomous mode and for
 programming skills.r1 is the rollers structure contatiing statisics information
 zScore is the z score corresponding to the confidence level(alpha) for the test.
 eject is for if it should pu the cube in place for towering, true for towering,
 false for putting it in the tray. Returns 0 when done. Recommended declaration
 autoCubeGrab(roller, 3, false);
*/
int autoCubeGrab(rollers r1, double zScore,bool eject, int maxTime)
{
		move(20);
		rollersArms(-100);
		rollersTray(-100);

		int flag = innerRollerBump(r1, zScore,maxTime);//grab and go forward until the inner rollers are bumped by the cube
if(flag == 2)
{
	move(0);//stops forward movement of the robot
	rollersArms(0);//sets the arm roller speed to zero
	rollersTray(0);//sets the tray roller speed to zero
	return 2;
	pros::delay(60000);
}
		move(0);//stops forward movement of the robot
		rollersArms(0);//sets the arm roller speed to zero
		rollersTray(0);//sets the tray roller speed to zero
		if(eject){
			rollersDegrees(150, 50);
		}else{
			rollersDegrees(-720, 100);
		}
		return flag;
}






/*
	Used with the ultrasonic sensor to find the center of a pole and turn to it.
	Length is the number of data points to collect, range [5 is a good number] is
	the number of data points to sample on each side of a point for an average,
	tInterval is the time in pros::c::milliseconds between samples minimum is 50 milliseconds, decay [0.0 â€“ 1.0] how
	slowly to decay from raw value.Speed determines the turn speed
*/
void centerDetect(int length, int range, int tInterval, double decay, int speed) //see also low-pass-filter-method now at [https://web.archive.org/web/20180922093343/http://www.robosoup.com/2014/01/cleaning-noisy-time-series-data-low-pass-filter-c.html] (no longer exists)[https://www.robosoup.com/2014/01/cleaning-noisy-time-series-data-low-pass-filter-c.html]
{
	int ns = length;
  double data[ns];
  double clean[ns];
	long t1 = pros::c::millis();
	long t2 = pros::c::millis();
  long t3;
	int iter;
    for(iter = 0;iter < ns;iter++)
    {
    	data[iter] = UltraSensor.get_value();
			if(data[iter] <= 0)
			{
				data[iter] = 5000;
			}
			//printf("Range: %f m\r\n",data[iter]);
			t2 = pros::c::millis();
				printf("\r\n%d, ",(int) (t2 - t1));
				printf("%d",(int)data[iter]);
  			t3 = pros::c::millis();
        while((t3-t1) < (tInterval * (iter + 1))) //-0.000031 is timing calibration value, todo, recalculate
        {
 					t3 = pros::c::millis();
					turn2(-speed,speed);
          pros::delay(1);
        }
    }
  turn2(0, 0);
	//printf("Data: %d",(int)data[1]);

	//If you are trying to figure out how this section works, good luck
/*
	//Calculate coefficients
  double coefficients[range+1];
  int i;
  for (i = 0; i <= range; i++)
  {
    coefficients[i] = pow((double)decay, (double)i);
      //printf("\nCoeff:%f",coefficients[i]);
  }
	//printf("Coeffs calcd");
  // calculate the divisor
  double divisor = 0;
  for (i = -range; i <= range; i++)
  {
    divisor += coefficients[abs(i)];
  }
	//printf("Divisor: %f",divisor);
  // clean data
  for (i = range; i < length - range; i++)
  {
    double temp = 0;
    int j;
    for (j = -range; j <= range; j++)
    {
      temp += data[i + j] * coefficients[abs(j)];
    }
    clean[i] = temp / divisor;
      //printf("Clean: %f\n",clean[i]);
  }

  // find leading and trailing slopes
  double leadSum = 0;
  double trailSum = 0;
  int leadRef = range;
  int trailRef = length - range - 1;
  for (i = 1; i <= range; i++)
  {
    leadSum += (clean[leadRef] - clean[leadRef + i]) / i;
    trailSum += (clean[trailRef] - clean[trailRef - i]) / i;
  }

  //clean edges
  double leadSlope = leadSum / range;
  double trailSlope = trailSum / range;
  for (i = 1; i <= range; i++)
  {
    clean[leadRef - i] = clean[leadRef] + leadSlope * i;
    clean[trailRef + i] = clean[trailRef] + trailSlope * i;
  }
    /*for(i=0;i<length;i++)
    {
     printf("Cleaned Data: %f\n", clean[i]);
	 }*/
	 //find the maximum value in the range, this should be the peak of a sine wave generated by looking at the pipe
	/*int pos = 3;
	 int x;
	 for(x = 4;x < length-4;x++)
	 {

		 if(clean[x] < clean[pos])
		 {
			 pos = x;
		 }
	 }*/
	 int pos = 0;
	 //calculate the inverse postition since it will be turnign backwards
	 ns = length - pos;
   t1 = pros::c::millis();
	 //printf("Ns: %d",ns);
	 //turn the robot to the intended position using time values
	 for(iter = 0;iter < ns ;iter++)
	 {
		 t3 = pros::c::millis();
		 while((t3 - t1) < (tInterval * (iter + 1))) //-0.000031 is timing calibration value
		 {
			 t3 = pros::c::millis();
			 turn2(speed,-speed);
			 pros::delay(1);
		 }
	 }
	 turn2(0,0);//sets the robots turn speed to zero so it stops turning

}

/*
 This functions serchs for and then navigates towards a  tower using a line
 follower like algorithm. lowerBound is the distacne a point must be above to
 trigger the navigation start, upperBound is the value the point must be below,
 tInterval is the time in milliseconds between samples(minimum of 50(approx:
 refresh rate of sensor)), turnSpeed is the speed the robot will turn at where
 positive turnSpeed is clockwise turning and negative turnSpeed is
 counterclockwise turning, moveSpeed is the speed to move the robot where
 positive moveSpeed is forward and negative moveSpeed is backward deployDistance
 is the distance in ultrasonic sensor units to move the arm up at.
*/
void towerDetect(int lowerBound, int upperBound, int tInterval, int turnSpeed, int moveSpeed, int deployDistance){
//turn2(0,0);
turn2(-3*turnSpeed,3*turnSpeed);

 /*while(true)
	{
		pros::delay(tInterval);
		printf("Range: %f m\r\n",(float)UltraSensor.get_value());
	}*/
	while(!(UltraSensor.get_value() > lowerBound && UltraSensor.get_value() < upperBound))//turns until it detects an object in the bounding area
	{
		pros::delay(tInterval);
		printf("Range: %f m\r\n",(float)UltraSensor.get_value());
	}
		turn2(-turnSpeed, turnSpeed);
	float x = UltraSensor.get_value();
	long t1 = pros::millis();
	bool ignore = true;
	while(x >= (float)UltraSensor.get_value() || ignore)
	{
		x = (float)UltraSensor.get_value();
		printf("Range: %f m\r\n",(float)x);
		ignore = false;
		if(pros::millis() - t1 < 500 && ((x < lowerBound) || (x > upperBound)))
		{
			ignore = true;
		}
		pros::delay(tInterval);
}
	printf("Range: %f m\r\n",(float)UltraSensor.get_value());
	printf("end\r\n");
	turn2(0,0);
/*	long t1, t2;
	t1 = pros::millis();
	/*bool a = false;
	while(a || (UltraSensor.get_value() > lowerBound && UltraSensor.get_value() < upperBound))//turns until it no longer detects an object in the bounding area
	{
		a = false;
		if(UltraSensor.get_value() == -1)
		{
			a = true;
		}
		pros::delay(tInterval);
		printf("Range: %f m\r\n",(float)UltraSensor.get_value());
	}
	t2 = pros::millis();
	turn2(turnSpeed, -turnSpeed);
	pros::delay((int)((t2 - t1) / 2)); // turn to the center of the object
move(moveSpeed);
	while(UltraSensor.get_value() < deployDistance)
	{
		pros::delay(tInterval);
	}*/
}
